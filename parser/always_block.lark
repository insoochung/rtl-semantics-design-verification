// Follow https://www.verilog.com/VerilogBNF.html and minimally extended to parse always blocks in IBEX RTL

start: always_statement

always_statement: ALWAYS always_condition? statement

BEGIN: "begin"
END: "end"

always_condition: "@(" edge_condition ("or" edge_condition)* ")"

edge_condition: EDGE identifier | expression

statement_or_null: statement
	| ";"

statement: tenary_assignment
	| assignment ";"
	| "assign" assignment ";"
	| "wait" "(" expression ")" statement_or_null
	| "-" name_of_event ";"
	| seq_block
	| if_else_statement
	| case_statement
	| for_statement
	| function_call ";"
	| "(" statement ")"

for_statement: "for" "(" for_condition ")" statement

for_condition: assignment ";" expression ";" assignment

if_else_statement: "if" "(" condition ")" statement_or_null
	| "if" "(" condition ")" statement_or_null "else" statement_or_null

condition: expression

case_statement: UNIQUE? CASE "(" condition ")" case_item+ "endcase"
	| UNIQUE? CASE "(" condition ")" case_item+ "endcase"
	| UNIQUE? CASE "(" condition ")" case_item+ "endcase"

assignment: lvalue ASSIGNMENT_OPERATOR expression
	| lvalue INC_DEC_OPERATOR?
	| INC_DEC_OPERATOR? lvalue
	| lvalue "<=" expression -> nonblocking_assignment

case_item: case_condition statement_or_null

case_condition: expression ("," expression)* ":"

?seq_block: BEGIN statement* END
	| BEGIN block_identifier statement* END block_identifier?

block_identifier: ":" IDENTIFIER

lvalue: identifier
	| identifier index+  ("." identifier)?
	| concatenation
	| var_type identifier

index: ("[" expression "]")
	| "[" constant_expression INDEXING_OPERATOR constant_expression "]"

var_type: DATATYPE SIGN?

constant_expression	: expression

mintypmax_expression: expression
	| expression ":" expression ":" expression

expression: primary
	| UNARY_OPERATOR primary
	| expression BINARY_OPERATOR expression
	| STRING
	| DEFAULT_BIT
	| primary "'(" primary ")"
	| dictionary
	| MACRO
	| "default"
	| "(" expression ")"
	| tenary_expression


tenary_assignment: lvalue ASSIGNMENT_OPERATOR tenary_expression ";"
	| "assign" lvalue ASSIGNMENT_OPERATOR tenary_expression ";"
tenary_expression: condition QUESTION_MARK expression ":" expression

primary: NUMBER
	| identifier
	| identifier index+ ("." identifier)?
	| concatenation
	| concatenation_assignment
	| multiple_concatenation
	| function_call
	| "(" mintypmax_expression ")"

concatenation: "{" expression (","expression)* "}"

concatenation_assignment: "'{" expression (","expression)* "}"

multiple_concatenation: "{" expression "{" expression (","expression)* "}" "}"

function_call: name_of_function arguments
	| name_of_system_function arguments

arguments: "(" expression ("," expression)* ")"
	| "()"

dictionary: "'{" primary ":" expression ("," primary ":" expression)*"}"

name_of_function: identifier | "printbuffer_dumpline"

name_of_system_function: "$" identifier

name_of_event: IDENTIFIER

?identifier: IDENTIFIER ("." IDENTIFIER)*

DEFAULT_BIT: "'{default: '0}"| "'{default: '1}"

INC_DEC_OPERATOR: "++" | "--"

UNARY_OPERATOR: "+"| "-"| "!"| "~"| "&"| "~&"| "|"| "^|"| "^"| "~^"

BINARY_OPERATOR: "+"|"-"|"*"|"/"|"%"|"=="|"!="|"==="|"!=="|"&&"|"||"|"<"|"<="|">"|">="|"&"|"|"|"^"|"^~"|">>"|"<<"|">>>"|"<<<"|"&&"

ASSIGNMENT_OPERATOR : "="|"+="|"-="|"*="|"/="|"%="|"&="|"|="|"^="|"<<="|">>="|"<<<="|">>>="

QUESTION_MARK: "?"

STRING: ESCAPED_STRING

ALWAYS: "always" | "always_ff" | "always_comb" | "always_latch"

EDGE: "posedge"|"negedge"

MACRO: "`" IDENTIFIER

UNIQUE: "unique"

CASE: "case" | "casez" | "casex"

DATATYPE: "int"
  | "float"

SIGN: "signed"
  | "unsigned"

INDEXING_OPERATOR: ":" | "+:" | "-:"

NUMBER: UNSIGNED_NUMBER BASE UNSIGNED_NUMBER
	| DECIMAL_NUMBER "." UNSIGNED_NUMBER
	| DECIMAL_NUMBER( "." UNSIGNED_NUMBER)? "E" DECIMAL_NUMBER
	| DECIMAL_NUMBER( "." UNSIGNED_NUMBER)? "e" DECIMAL_NUMBER
	| DECIMAL_NUMBER
	| SCALAR_CONSTANT


SCALAR_CONSTANT: "1'b0"|"1'b1"|"1'B0"|"1'B1"|"'b0"|"'b1"|"'B0"|"'B1"|"1"|"0"|"'1"|"'0"

DECIMAL_NUMBER:("+"|"-")? UNSIGNED_NUMBER

UNSIGNED_NUMBER:(HEXDIGIT|"_"|"z"|"Z"|"x"|"X")+

BASE:"'b"|"'B"|"'o"|"'O"|"'d"|"'D"|"'h"|"'H"

IDENTIFIER: CNAME
          | ESCAPED_IDENTIFIER

// Lark
ESCAPED_IDENTIFIER: /\\([^\s]+)/
COMMENT: "//" /[^\n]*/ NEWLINE
NEWLINE: "\n"
MULTILINE_COMMENT: /\/\*(\*(?!\/)|[^*])*\*\//

%import common.CNAME
%import common.ESCAPED_STRING
%import common.DIGIT
%import common.HEXDIGIT
%import common.WS

%ignore WS
%ignore COMMENT
%ignore MULTILINE_COMMENT
%ignore NEWLINE

